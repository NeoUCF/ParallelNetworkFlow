\section{Edmonds-Karp}
In 1972 Edmonds and Karp published a paper detailing a specific protocol using the Ford-Fulkerson method for computing max flow and min cut. The Edmonds-Karp (EK) algorithm is one of the earliest solutions for solving the maximum flow in a network of nodes that can be represented as a graph. Unlike its predecessor, it has a well defined specification on how to perform searches for augmenting paths. While Ford-Fulkerson may use any search method, often DFS, EK requires the use of BFS to find augmenting paths which improves theoretical runtimes from $\mathcal{O}(E|f|)$, where $f$ is the max flow of the graph, to $\mathcal{O}(V^2E)$.

\subsection{Sequential Algorithm}
In order to test our parallel algorithm on correctness and speed, we implemented the EK algorithm in Java by editing an existing version of the algorithm written by one of our fellow classmates, Pedro Contepelli, who has given us full permission to use and edit his code for our research as needed. The algorithm uses three different classes to maintain a graph (\textit{Graph}), its edges (\textit{Edge}), and its nodes (\textit{Node}).  
    
A \textit{Graph} is instantiated from a text based input file holding the matrix representing the graph and the number of \textit{Node}s it has. The source and the sink are assumed to be $0$ and $n-1$ respectively. The \textit{Graph} also has a method \textit{getAugPath()} which returns an augmenting path in the graph.

From there \textit{main()} runs the EK algorithm to compute the max flow for the graph. It does this by finding the maximum flow that can be pushed through the obtained path and then adds each edge's flow to the forward flow of the edge and subtracts it from the reverse flow of the edge. It should be noted that this algorithm is also useful in solving the min-cut problem as well as the max flow problem because they are both the same problem [Ford-Fulkerson].
    
\subsection{Parallel Algorithm}
We believe there are two distinct ways to transform the sequential Edmonds-Karp algorithm into a version that applies some concurrency to the algorithm. The first is strictly through parallelization of the BFS algorithm to decrease the augmenting paths search time, and the second is by using fine-grained locking techniques to build augmenting paths in parallel using several threads running BFS concurrently on a single graph data structure. We will discuss each approach and explain why we chose attempt to build a concurrent graph using Java's parallel libraries.
    
\subsubsection{Parallel Breadth-First-Search}
Implementing a parallel BFS was the first thought that came to mind when attempting to create a parallel implementation of the EK algorithm. BFS is an incredibly time intensive task running in $\mathcal{O}(V+E)$ time while the rest of the algorithm simply adds a multiple of the BFS run time because calculations are performed on the path BFS finds. If we could speedup the search rate for an augmenting path then we could potentially see impressive gains in speedup for the overall EK algorithm. Taking this approach would prove difficult, however, as other research says that BFS is not easily parallelizable which lead us to parallelization \cite{vineet}.

\subsubsection{Parallel Augmenting Paths}
It is possible to allow multiple threads to try to update the graph based on the augmenting path they have found. There are two possible ways to handle these graph updates in a concurrent environment. We could use coarse-grained locks on the graph data structure while the flows and capacities are being updated to ensure mutual exclusion. This approach could produce significantly less speedup than desired due to the locks potentially forcing the program into a sequential state. Another option would be to create a fine-grained locking system that only locks the current augmented path edges while they are being updated.   

Using a coarse-grained lock would allow BFS computations for augmenting paths to be done in parallel while locking the calculations necessary to update the flows and capacities of each of the edges in the augmenting path. Unfortunately, this method would not be particularly useful because each augmenting path found in parallel would then be discarded when one of the threads successfully updates the graph. This parallel version would be significantly easier to write than implementing a parallel BFS, but could lead to the algorithm being nearly sequential as mentioned earlier so we will try another method.

Applying fine-grained locking techniques to the \textit{Graph} will allow it to become a more versatile concurrent data structure. Instead of refusing access to the entire \textit{Graph} we can simply lock the parts of the graph that we need to perform calculations on, namely the path generated by BFS, while other threads are free to perform work on parts of the \textit{Graph} that have not yet been locked.

\subsubsection{Fine-Grained Concurrent Graph}
To build a fine-grained concurrent data structure we have to take careful consideration in how we implement each field and method associated with the object. For the parallel EK algorithm we will need to create a shared memory \textit{Graph} that is capable of being searched by several threads and then having updates to the residual capacities and flows of those paths applied in parallel. To achieve this we will lock each edge of the augmenting path as it is being added to our augmenting path variable to ensure no other threads try to make residual capacity or flow updates to the edges in the current thread's augmenting path. In short, we need to add a lock to \textit{Edge} and require threads to acquire this \textit{Edge}'s lock before continuing. We define the specifications we think are required to create a concurrent \textit{Graph} in pseudo code in the Algorithm \ref{EKClasses}

As described, the function locks the edges of the path as it builds it so that other threads cannot try to access the same $ConcurrentEdge$ at the same time. These classes are very specific to the EK algorithm and require the $run$ method to be run to for each of these class methods to work properly, specifically the $getAugmentingPath$ method relies on the $edmondsKarp$ method from Algorithm \ref{EKP} to unlock each $ConcurrentEdge$ in the path before starting another BFS.

\subsection{Testing \& Results}
Preliminary results show that the parallel algorithm runs in approximately the same time as the sequential algorithm, but formal testing is still in progress.

\clearpage
\begin{algorithm} 
\caption{Concurrent Classes}
\label{EKClasses}
    \begin{algorithmic}[1]
    \State \textbf{class} $ConcurrentGraph$ \\
        \Function{getAugmentingPath}{}
            \State $path \gets$ array of $Edges$
            \State $queue \gets$ empty queue of $Nodes$
            \State add source node to $queue$
            \While {$queue$ is not empty}
                \State remove node from $queue$
                \For{each edge in the current node}
                    \If{meets augmenting path requirements}
                        \State try to acquire edge lock
                        \If{successful}
                            \State add edge to augmenting path
                            \State add node connected to edge to $queue$
                        \Else
                            \State add removed node back to queue
                        \EndIf
                    \EndIf
                \EndFor
            \EndWhile
        \EndFunction
    \\ \\
    \State \textbf{class} $ConcurrentNode$
        \State $edges\gets$ array of edges
    \\
    \State \textbf{class} $ConcurrentEdge$
        \State $u \gets$ integer
        \State $v \gets$ integer
        \State $flow \gets$ integer
        \State $capacity \gets$ integer
        \State $reverse \gets Edge$
        \State $lock \gets$ reentrant lock
        \Function{lock}{}
            \State \textbf{do} $lock$.lock
        \EndFunction
        \Function{unlock}{}
            \State \textbf{do} $lock$.unlock
        \EndFunction
    \end{algorithmic}   
\end{algorithm}

\begin{algorithm} 
\caption{Edmonds-Karp Parallel Implementation}
\label{EKP}
    \begin{algorithmic}[1]
    \Function{edmondsKarp}{}
        \State $graph \gets$ constructor creates graph from file
        \State $maxFlow \gets$ integer
        \While{true}
            \State $path \gets getAugmentingPath$
            \If{$path$ does not contain the sink}
                \Return
            \Else
                \State $forwardFlow \gets INFINITY$
                \For{each $ConcurrentEdge$ in $path$}
                    \State $forwardFlow \gets$ minimum residual flow
                \EndFor
                \For{each $ConcurrentEdge$ in $path$}
                    \State add $forwardFlow$ to $flow$
                    \State{subtract $forwardFlow$ from $reverseFlow$}
                \EndFor
                \State $maxFlow \gets maxFlow + pushFlow$
                \For{each $ConcurrentEdge$ in $path$}
                    \State \textbf{do} $ConcurrentEdge.lock$.unlock
                \EndFor
            \EndIf
        \EndWhile
    \EndFunction
    \end{algorithmic}
\end{algorithm}
\clearpage